{
  "version": 3,
  "sources": ["../../framer-motion/dist/es/components/AnimatePresence/index.mjs", "../../framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs", "../../framer-motion/dist/es/components/AnimatePresence/PopChild.mjs", "../../framer-motion/dist/es/utils/use-composed-ref.mjs", "../../framer-motion/dist/es/components/AnimatePresence/utils.mjs", "../../framer-motion/dist/es/components/LayoutGroup/index.mjs", "../../framer-motion/dist/es/context/DeprecatedLayoutGroupContext.mjs", "../../framer-motion/dist/es/utils/use-force-update.mjs", "../../framer-motion/dist/es/utils/use-is-mounted.mjs", "../../framer-motion/dist/es/projection/node/group.mjs", "../../framer-motion/dist/es/components/LazyMotion/index.mjs", "../../framer-motion/dist/es/components/MotionConfig/index.mjs", "../../framer-motion/dist/es/render/components/create-proxy.mjs", "../../framer-motion/dist/es/render/components/m/proxy.mjs", "../../framer-motion/dist/es/render/components/motion/proxy.mjs", "../../framer-motion/dist/es/utils/use-unmount-effect.mjs", "../../framer-motion/dist/es/render/dom/features-animation.mjs", "../../framer-motion/dist/es/render/dom/features-max.mjs", "../../framer-motion/dist/es/render/dom/features-min.mjs", "../../framer-motion/dist/es/utils/use-motion-value-event.mjs", "../../framer-motion/dist/es/value/use-scroll.mjs", "../../framer-motion/dist/es/render/dom/scroll/info.mjs", "../../framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs", "../../framer-motion/dist/es/render/dom/scroll/offsets/edge.mjs", "../../framer-motion/dist/es/render/dom/scroll/offsets/offset.mjs", "../../framer-motion/dist/es/render/dom/scroll/offsets/presets.mjs", "../../framer-motion/dist/es/render/dom/scroll/offsets/index.mjs", "../../framer-motion/dist/es/render/dom/scroll/on-scroll-handler.mjs", "../../framer-motion/dist/es/render/dom/scroll/track.mjs", "../../framer-motion/dist/es/render/dom/scroll/utils/get-timeline.mjs", "../../framer-motion/dist/es/render/dom/scroll/attach-animation.mjs", "../../framer-motion/dist/es/render/dom/scroll/attach-function.mjs", "../../framer-motion/dist/es/render/dom/scroll/index.mjs", "../../framer-motion/dist/es/value/scroll/use-element-scroll.mjs", "../../framer-motion/dist/es/value/scroll/use-viewport-scroll.mjs", "../../framer-motion/dist/es/value/use-motion-value.mjs", "../../framer-motion/dist/es/value/use-combine-values.mjs", "../../framer-motion/dist/es/value/use-motion-template.mjs", "../../framer-motion/dist/es/value/use-spring.mjs", "../../framer-motion/dist/es/value/use-computed.mjs", "../../framer-motion/dist/es/value/use-transform.mjs", "../../framer-motion/dist/es/utils/use-animation-frame.mjs", "../../framer-motion/dist/es/value/use-time.mjs", "../../framer-motion/dist/es/value/use-velocity.mjs", "../../framer-motion/dist/es/value/use-will-change/WillChangeMotionValue.mjs", "../../framer-motion/dist/es/value/use-will-change/index.mjs", "../../framer-motion/dist/es/utils/reduced-motion/use-reduced-motion.mjs", "../../framer-motion/dist/es/utils/reduced-motion/use-reduced-motion-config.mjs", "../../framer-motion/dist/es/animation/hooks/animation-controls.mjs", "../../framer-motion/dist/es/animation/utils/is-dom-keyframes.mjs", "../../framer-motion/dist/es/animation/animate/resolve-subjects.mjs", "../../framer-motion/dist/es/animation/sequence/utils/calc-repeat-duration.mjs", "../../framer-motion/dist/es/animation/sequence/utils/calc-time.mjs", "../../framer-motion/dist/es/animation/sequence/utils/edit.mjs", "../../framer-motion/dist/es/animation/sequence/utils/normalize-times.mjs", "../../framer-motion/dist/es/animation/sequence/utils/sort.mjs", "../../framer-motion/dist/es/animation/sequence/create.mjs", "../../framer-motion/dist/es/render/object/ObjectVisualElement.mjs", "../../framer-motion/dist/es/animation/utils/create-visual-element.mjs", "../../framer-motion/dist/es/animation/animate/subject.mjs", "../../framer-motion/dist/es/animation/animate/sequence.mjs", "../../framer-motion/dist/es/animation/animate/index.mjs", "../../framer-motion/dist/es/animation/hooks/use-animate.mjs", "../../framer-motion/dist/es/animation/animators/waapi/animate-elements.mjs", "../../framer-motion/dist/es/animation/animators/waapi/animate-style.mjs", "../../framer-motion/dist/es/animation/hooks/use-animate-style.mjs", "../../framer-motion/dist/es/animation/hooks/use-animation.mjs", "../../framer-motion/dist/es/components/AnimatePresence/use-presence-data.mjs", "../../framer-motion/dist/es/events/use-dom-event.mjs", "../../framer-motion/dist/es/gestures/drag/use-drag-controls.mjs", "../../framer-motion/dist/es/motion/utils/is-motion-component.mjs", "../../framer-motion/dist/es/motion/utils/unwrap-motion-component.mjs", "../../framer-motion/dist/es/projection/use-instant-layout-transition.mjs", "../../framer-motion/dist/es/projection/use-reset-projection.mjs", "../../framer-motion/dist/es/utils/use-cycle.mjs", "../../framer-motion/dist/es/utils/use-in-view.mjs", "../../framer-motion/dist/es/render/dom/viewport/index.mjs", "../../framer-motion/dist/es/utils/use-instant-transition.mjs", "../../framer-motion/dist/es/utils/use-page-in-view.mjs", "../../framer-motion/dist/es/animation/optimized-appear/store.mjs", "../../framer-motion/dist/es/animation/optimized-appear/store-id.mjs", "../../framer-motion/dist/es/animation/optimized-appear/handoff.mjs", "../../framer-motion/dist/es/animation/optimized-appear/start.mjs", "../../framer-motion/dist/es/animation/hooks/use-animated-state.mjs", "../../framer-motion/dist/es/components/AnimateSharedLayout.mjs", "../../framer-motion/dist/es/value/use-inverted-scale.mjs", "../../framer-motion/dist/es/components/Reorder/namespace.mjs", "../../framer-motion/dist/es/components/Reorder/Group.mjs", "../../framer-motion/dist/es/context/ReorderContext.mjs", "../../framer-motion/dist/es/components/Reorder/utils/check-reorder.mjs", "../../framer-motion/dist/es/components/Reorder/Item.mjs"],
  "sourcesContent": ["\"use client\";\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useMemo, useRef, useState, useContext } from 'react';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { usePresence } from './use-presence.mjs';\nimport { onlyElements, getChildKey } from './utils.mjs';\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = \"sync\", propagate = false, anchorX = \"left\", root }) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate);\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = useMemo(() => onlyElements(children), [children]);\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = useRef(true);\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = useRef(presentChildren);\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map());\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren);\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        pendingPresentChildren.current = presentChildren;\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i]);\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false);\n                }\n            }\n            else {\n                exitComplete.delete(key);\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\n    const exitingChildren = [];\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren];\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i];\n            const key = getChildKey(child);\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child);\n                exitingChildren.push(child);\n            }\n        }\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */\n        if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren;\n        }\n        setRenderedChildren(onlyElements(nextChildren));\n        setDiffedChildren(presentChildren);\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return null;\n    }\n    if (process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        renderedChildren.length > 1) {\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n    }\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = useContext(LayoutGroupContext);\n    return (jsx(Fragment, { children: renderedChildren.map((child) => {\n            const key = getChildKey(child);\n            const isPresent = propagate && !isParentPresent\n                ? false\n                : presentChildren === renderedChildren ||\n                    presentKeys.includes(key);\n            const onExit = () => {\n                if (exitComplete.has(key)) {\n                    exitComplete.set(key, true);\n                }\n                else {\n                    return;\n                }\n                let isEveryExitComplete = true;\n                exitComplete.forEach((isExitComplete) => {\n                    if (!isExitComplete)\n                        isEveryExitComplete = false;\n                });\n                if (isEveryExitComplete) {\n                    forceRender?.();\n                    setRenderedChildren(pendingPresentChildren.current);\n                    propagate && safeToRemove?.();\n                    onExitComplete && onExitComplete();\n                }\n            };\n            return (jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial\n                    ? undefined\n                    : false, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, root: root, onExitComplete: isPresent ? undefined : onExit, anchorX: anchorX, children: child }, key));\n        }) }));\n};\n\nexport { AnimatePresence };\n", "\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport { useId, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\n\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, root }) => {\n    const presenceChildren = useConstant(newChildrenMap);\n    const id = useId();\n    let isReusedContext = true;\n    let context = useMemo(() => {\n        isReusedContext = false;\n        return {\n            id,\n            initial,\n            isPresent,\n            custom,\n            onExitComplete: (childId) => {\n                presenceChildren.set(childId, true);\n                for (const isComplete of presenceChildren.values()) {\n                    if (!isComplete)\n                        return; // can stop searching when any is incomplete\n                }\n                onExitComplete && onExitComplete();\n            },\n            register: (childId) => {\n                presenceChildren.set(childId, false);\n                return () => presenceChildren.delete(childId);\n            },\n        };\n    }, [isPresent, presenceChildren, onExitComplete]);\n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    if (presenceAffectsLayout && isReusedContext) {\n        context = { ...context };\n    }\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete();\n    }, [isPresent]);\n    if (mode === \"popLayout\") {\n        children = (jsx(PopChild, { isPresent: isPresent, anchorX: anchorX, root: root, children: children }));\n    }\n    return (jsx(PresenceContext.Provider, { value: context, children: children }));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n", "\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { isHTMLElement } from 'motion-dom';\nimport * as React from 'react';\nimport { useId, useRef, useContext, useInsertionEffect } from 'react';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { useComposedRefs } from '../../utils/use-composed-ref.mjs';\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component {\n    getSnapshotBeforeUpdate(prevProps) {\n        const element = this.props.childRef.current;\n        if (element && prevProps.isPresent && !this.props.isPresent) {\n            const parent = element.offsetParent;\n            const parentWidth = isHTMLElement(parent)\n                ? parent.offsetWidth || 0\n                : 0;\n            const size = this.props.sizeRef.current;\n            size.height = element.offsetHeight || 0;\n            size.width = element.offsetWidth || 0;\n            size.top = element.offsetTop;\n            size.left = element.offsetLeft;\n            size.right = parentWidth - size.width - size.left;\n        }\n        return null;\n    }\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() { }\n    render() {\n        return this.props.children;\n    }\n}\nfunction PopChild({ children, isPresent, anchorX, root }) {\n    const id = useId();\n    const ref = useRef(null);\n    const size = useRef({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n    });\n    const { nonce } = useContext(MotionConfigContext);\n    const composedRef = useComposedRefs(ref, children?.ref);\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left, right } = size.current;\n        if (isPresent || !ref.current || !width || !height)\n            return;\n        const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`;\n        ref.current.dataset.motionPopId = id;\n        const style = document.createElement(\"style\");\n        if (nonce)\n            style.nonce = nonce;\n        const parent = root ?? document.head;\n        parent.appendChild(style);\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            top: ${top}px !important;\n          }\n        `);\n        }\n        return () => {\n            if (parent.contains(style)) {\n                parent.removeChild(style);\n            }\n        };\n    }, [isPresent]);\n    return (jsx(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: React.cloneElement(children, { ref: composedRef }) }));\n}\n\nexport { PopChild };\n", "import * as React from 'react';\n\n/**\n * Taken from https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef(ref, value) {\n    if (typeof ref === \"function\") {\n        return ref(value);\n    }\n    else if (ref !== null && ref !== undefined) {\n        ref.current = value;\n    }\n}\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs(...refs) {\n    return (node) => {\n        let hasCleanup = false;\n        const cleanups = refs.map((ref) => {\n            const cleanup = setRef(ref, node);\n            if (!hasCleanup && typeof cleanup === \"function\") {\n                hasCleanup = true;\n            }\n            return cleanup;\n        });\n        // React <19 will log an error to the console if a callback ref returns a\n        // value. We don't use ref cleanups internally so this will only happen if a\n        // user's ref callback returns a value, which we only expect if they are\n        // using the cleanup functionality added in React 19.\n        if (hasCleanup) {\n            return () => {\n                for (let i = 0; i < cleanups.length; i++) {\n                    const cleanup = cleanups[i];\n                    if (typeof cleanup === \"function\") {\n                        cleanup();\n                    }\n                    else {\n                        setRef(refs[i], null);\n                    }\n                }\n            };\n        }\n    };\n}\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs(...refs) {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { useComposedRefs };\n", "import { Children, isValidElement } from 'react';\n\nconst getChildKey = (child) => child.key || \"\";\nfunction onlyElements(children) {\n    const filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, (child) => {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n\nexport { getChildKey, onlyElements };\n", "\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { useContext, useRef, useMemo } from 'react';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { DeprecatedLayoutGroupContext } from '../../context/DeprecatedLayoutGroupContext.mjs';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { nodeGroup } from '../../projection/node/group.mjs';\n\nconst shouldInheritGroup = (inherit) => inherit === true;\nconst shouldInheritId = (inherit) => shouldInheritGroup(inherit === true) || inherit === \"id\";\nconst LayoutGroup = ({ children, id, inherit = true }) => {\n    const layoutGroupContext = useContext(LayoutGroupContext);\n    const deprecatedLayoutGroupContext = useContext(DeprecatedLayoutGroupContext);\n    const [forceRender, key] = useForceUpdate();\n    const context = useRef(null);\n    const upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;\n    if (context.current === null) {\n        if (shouldInheritId(inherit) && upstreamId) {\n            id = id ? upstreamId + \"-\" + id : upstreamId;\n        }\n        context.current = {\n            id,\n            group: shouldInheritGroup(inherit)\n                ? layoutGroupContext.group || nodeGroup()\n                : nodeGroup(),\n        };\n    }\n    const memoizedContext = useMemo(() => ({ ...context.current, forceRender }), [key]);\n    return (jsx(LayoutGroupContext.Provider, { value: memoizedContext, children: children }));\n};\n\nexport { LayoutGroup };\n", "\"use client\";\nimport { createContext } from 'react';\n\n/**\n * Note: Still used by components generated by old versions of Framer\n *\n * @deprecated\n */\nconst DeprecatedLayoutGroupContext = createContext(null);\n\nexport { DeprecatedLayoutGroupContext };\n", "\"use client\";\nimport { frame } from 'motion-dom';\nimport { useState, useCallback } from 'react';\nimport { useIsMounted } from './use-is-mounted.mjs';\n\nfunction useForceUpdate() {\n    const isMounted = useIsMounted();\n    const [forcedRenderCount, setForcedRenderCount] = useState(0);\n    const forceRender = useCallback(() => {\n        isMounted.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [forcedRenderCount]);\n    /**\n     * Defer this to the end of the next animation frame in case there are multiple\n     * synchronous calls.\n     */\n    const deferredForceRender = useCallback(() => frame.postRender(forceRender), [forceRender]);\n    return [deferredForceRender, forcedRenderCount];\n}\n\nexport { useForceUpdate };\n", "\"use client\";\nimport { useRef } from 'react';\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-effect.mjs';\n\nfunction useIsMounted() {\n    const isMounted = useRef(false);\n    useIsomorphicLayoutEffect(() => {\n        isMounted.current = true;\n        return () => {\n            isMounted.current = false;\n        };\n    }, []);\n    return isMounted;\n}\n\nexport { useIsMounted };\n", "const notify = (node) => !node.isLayoutDirty && node.willUpdate(false);\nfunction nodeGroup() {\n    const nodes = new Set();\n    const subscriptions = new WeakMap();\n    const dirtyAll = () => nodes.forEach(notify);\n    return {\n        add: (node) => {\n            nodes.add(node);\n            subscriptions.set(node, node.addEventListener(\"willUpdate\", dirtyAll));\n        },\n        remove: (node) => {\n            nodes.delete(node);\n            const unsubscribe = subscriptions.get(node);\n            if (unsubscribe) {\n                unsubscribe();\n                subscriptions.delete(node);\n            }\n            dirtyAll();\n        },\n        dirty: dirtyAll,\n    };\n}\n\nexport { nodeGroup };\n", "\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { useState, useRef, useEffect } from 'react';\nimport { LazyContext } from '../../context/LazyContext.mjs';\nimport { loadFeatures } from '../../motion/features/load-features.mjs';\n\n/**\n * Used in conjunction with the `m` component to reduce bundle size.\n *\n * `m` is a version of the `motion` component that only loads functionality\n * critical for the initial render.\n *\n * `LazyMotion` can then be used to either synchronously or asynchronously\n * load animation and gesture support.\n *\n * ```jsx\n * // Synchronous loading\n * import { LazyMotion, m, domAnimation } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={domAnimation}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n *\n * // Asynchronous loading\n * import { LazyMotion, m } from \"framer-motion\"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={() => import('./path/to/domAnimation')}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction LazyMotion({ children, features, strict = false }) {\n    const [, setIsLoaded] = useState(!isLazyBundle(features));\n    const loadedRenderer = useRef(undefined);\n    /**\n     * If this is a synchronous load, load features immediately\n     */\n    if (!isLazyBundle(features)) {\n        const { renderer, ...loadedFeatures } = features;\n        loadedRenderer.current = renderer;\n        loadFeatures(loadedFeatures);\n    }\n    useEffect(() => {\n        if (isLazyBundle(features)) {\n            features().then(({ renderer, ...loadedFeatures }) => {\n                loadFeatures(loadedFeatures);\n                loadedRenderer.current = renderer;\n                setIsLoaded(true);\n            });\n        }\n    }, []);\n    return (jsx(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict }, children: children }));\n}\nfunction isLazyBundle(features) {\n    return typeof features === \"function\";\n}\n\nexport { LazyMotion };\n", "\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { useContext, useMemo } from 'react';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { loadExternalIsValidProp } from '../../render/dom/utils/filter-props.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\n\n/**\n * `MotionConfig` is used to set configuration options for all children `motion` components.\n *\n * ```jsx\n * import { motion, MotionConfig } from \"framer-motion\"\n *\n * export function App() {\n *   return (\n *     <MotionConfig transition={{ type: \"spring\" }}>\n *       <motion.div animate={{ x: 100 }} />\n *     </MotionConfig>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction MotionConfig({ children, isValidProp, ...config }) {\n    isValidProp && loadExternalIsValidProp(isValidProp);\n    /**\n     * Inherit props from any parent MotionConfig components\n     */\n    config = { ...useContext(MotionConfigContext), ...config };\n    /**\n     * Don't allow isStatic to change between renders as it affects how many hooks\n     * motion components fire.\n     */\n    config.isStatic = useConstant(() => config.isStatic);\n    /**\n     * Creating a new config context object will re-render every `motion` component\n     * every time it renders. So we only want to create a new one sparingly.\n     */\n    const context = useMemo(() => config, [\n        JSON.stringify(config.transition),\n        config.transformPagePoint,\n        config.reducedMotion,\n    ]);\n    return (jsx(MotionConfigContext.Provider, { value: context, children: children }));\n}\n\nexport { MotionConfig };\n", "import { warnOnce } from 'motion-utils';\nimport { createMotionComponent } from '../../motion/index.mjs';\n\nfunction createMotionProxy(preloadedFeatures, createVisualElement) {\n    if (typeof Proxy === \"undefined\") {\n        return createMotionComponent;\n    }\n    /**\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n     * Rather than generating them anew every render.\n     */\n    const componentCache = new Map();\n    const factory = (Component, options) => {\n        return createMotionComponent(Component, options, preloadedFeatures, createVisualElement);\n    };\n    /**\n     * Support for deprecated`motion(Component)` pattern\n     */\n    const deprecatedFactoryFunction = (Component, options) => {\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(false, \"motion() is deprecated. Use motion.create() instead.\");\n        }\n        return factory(Component, options);\n    };\n    return new Proxy(deprecatedFactoryFunction, {\n        /**\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\n         * DOM component with that name.\n         */\n        get: (_target, key) => {\n            if (key === \"create\")\n                return factory;\n            /**\n             * If this element doesn't exist in the component cache, create it and cache.\n             */\n            if (!componentCache.has(key)) {\n                componentCache.set(key, createMotionComponent(key, undefined, preloadedFeatures, createVisualElement));\n            }\n            return componentCache.get(key);\n        },\n    });\n}\n\nexport { createMotionProxy };\n", "import { createMotionProxy } from '../create-proxy.mjs';\n\nconst m = /*@__PURE__*/ createMotionProxy();\n\nexport { m };\n", "import { createDomVisualElement } from '../../dom/create-visual-element.mjs';\nimport { createMotionProxy } from '../create-proxy.mjs';\nimport { featureBundle } from './feature-bundle.mjs';\n\nconst motion = /*@__PURE__*/ createMotionProxy(featureBundle, createDomVisualElement);\n\nexport { motion };\n", "\"use client\";\nimport { useEffect } from 'react';\n\nfunction useUnmountEffect(callback) {\n    return useEffect(() => () => callback(), []);\n}\n\nexport { useUnmountEffect };\n", "\"use client\";\nimport { animations } from '../../motion/features/animations.mjs';\nimport { gestureAnimations } from '../../motion/features/gestures.mjs';\nimport { createDomVisualElement } from './create-visual-element.mjs';\n\n/**\n * @public\n */\nconst domAnimation = {\n    renderer: createDomVisualElement,\n    ...animations,\n    ...gestureAnimations,\n};\n\nexport { domAnimation };\n", "\"use client\";\nimport { drag } from '../../motion/features/drag.mjs';\nimport { layout } from '../../motion/features/layout.mjs';\nimport { domAnimation } from './features-animation.mjs';\n\n/**\n * @public\n */\nconst domMax = {\n    ...domAnimation,\n    ...drag,\n    ...layout,\n};\n\nexport { domMax };\n", "\"use client\";\nimport { animations } from '../../motion/features/animations.mjs';\nimport { createDomVisualElement } from './create-visual-element.mjs';\n\n/**\n * @public\n */\nconst domMin = {\n    renderer: createDomVisualElement,\n    ...animations,\n};\n\nexport { domMin };\n", "\"use client\";\nimport { useInsertionEffect } from 'react';\n\nfunction useMotionValueEvent(value, event, callback) {\n    /**\n     * useInsertionEffect will create subscriptions before any other\n     * effects will run. Effects run upwards through the tree so it\n     * can be that binding a useLayoutEffect higher up the tree can\n     * miss changes from lower down the tree.\n     */\n    useInsertionEffect(() => value.on(event, callback), [value, event, callback]);\n}\n\nexport { useMotionValueEvent };\n", "\"use client\";\nimport { motionValue } from 'motion-dom';\nimport { invariant } from 'motion-utils';\nimport { useRef, useCallback, useEffect } from 'react';\nimport { scroll } from '../render/dom/scroll/index.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\n\nconst createScrollMotionValues = () => ({\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0),\n});\nconst isRefPending = (ref) => {\n    if (!ref)\n        return false;\n    return !ref.current;\n};\nfunction useScroll({ container, target, ...options } = {}) {\n    const values = useConstant(createScrollMotionValues);\n    const scrollAnimation = useRef(null);\n    const needsStart = useRef(false);\n    const start = useCallback(() => {\n        scrollAnimation.current = scroll((_progress, { x, y, }) => {\n            values.scrollX.set(x.current);\n            values.scrollXProgress.set(x.progress);\n            values.scrollY.set(y.current);\n            values.scrollYProgress.set(y.progress);\n        }, {\n            ...options,\n            container: container?.current || undefined,\n            target: target?.current || undefined,\n        });\n        return () => {\n            scrollAnimation.current?.();\n        };\n    }, [container, target, JSON.stringify(options.offset)]);\n    useIsomorphicLayoutEffect(() => {\n        needsStart.current = false;\n        if (isRefPending(container) || isRefPending(target)) {\n            needsStart.current = true;\n            return;\n        }\n        else {\n            return start();\n        }\n    }, [start]);\n    useEffect(() => {\n        if (needsStart.current) {\n            invariant(!isRefPending(container), \"Container ref is defined but not hydrated\", \"use-scroll-ref\");\n            invariant(!isRefPending(target), \"Target ref is defined but not hydrated\", \"use-scroll-ref\");\n            return start();\n        }\n        else {\n            return;\n        }\n    }, [start]);\n    return values;\n}\n\nexport { useScroll };\n", "import { progress, velocityPerSecond } from 'motion-utils';\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50;\nconst createAxisInfo = () => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n});\nconst createScrollInfo = () => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n});\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element[`scroll${position}`];\n    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, \"x\", info, time);\n    updateAxisInfo(element, \"y\", info, time);\n    info.time = time;\n}\n\nexport { createScrollInfo, updateScrollInfo };\n", "import { isHTMLElement } from 'motion-dom';\n\nfunction calcInset(element, container) {\n    const inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (isHTMLElement(current)) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        }\n        else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        }\n        else {\n            break;\n        }\n    }\n    return inset;\n}\n\nexport { calcInset };\n", "const namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n};\nfunction resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (edge in namedEdges) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber;\n        }\n        else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100;\n        }\n        else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\n        }\n        else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\n        }\n        else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\n\nexport { namedEdges, resolveEdge };\n", "import { resolveEdge, namedEdges } from './edge.mjs';\n\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (typeof offset === \"string\") {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n\nexport { resolveOffset };\n", "const ScrollOffset = {\n    Enter: [\n        [0, 1],\n        [1, 1],\n    ],\n    Exit: [\n        [0, 0],\n        [1, 0],\n    ],\n    Any: [\n        [1, 0],\n        [0, 1],\n    ],\n    All: [\n        [0, 0],\n        [1, 1],\n    ],\n};\n\nexport { ScrollOffset };\n", "import { interpolate, defaultOffset } from 'motion-dom';\nimport { clamp } from 'motion-utils';\nimport { calcInset } from './inset.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { ScrollOffset } from './presets.mjs';\n\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition), { clamp: false });\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));\n}\n\nexport { resolveOffsets };\n", "import { warnOnce } from 'motion-utils';\nimport { updateScrollInfo } from './info.mjs';\nimport { resolveOffsets } from './offsets/index.mjs';\n\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */\n    if (process.env.NODE_ENV !== \"production\") {\n        if (container && target && target !== container) {\n            warnOnce(getComputedStyle(container).position !== \"static\", \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\");\n        }\n    }\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n    return {\n        measure: (time) => {\n            measure(element, options.target, info);\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: () => onScroll(info),\n    };\n}\n\nexport { createOnScrollHandler };\n", "import { resize, frame, cancelFrame, frameData } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { createScrollInfo } from './info.mjs';\nimport { createOnScrollHandler } from './on-scroll-handler.mjs';\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst getEventTarget = (element) => element === document.scrollingElement ? window : element;\nfunction scrollInfo(onScroll, { container = document.scrollingElement, ...options } = {}) {\n    if (!container)\n        return noop;\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers) {\n                handler.measure(frameData.timestamp);\n            }\n            frame.preUpdate(notifyAll);\n        };\n        const notifyAll = () => {\n            for (const handler of containerHandlers) {\n                handler.notify();\n            }\n        };\n        const listener = () => frame.read(measureAll);\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener(\"resize\", listener, { passive: true });\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener(\"scroll\", listener, { passive: true });\n        listener();\n    }\n    const listener = scrollListeners.get(container);\n    frame.read(listener, false, true);\n    return () => {\n        cancelFrame(listener);\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container);\n        if (!currentHandlers)\n            return;\n        currentHandlers.delete(containerHandler);\n        if (currentHandlers.size)\n            return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n            resizeListeners.get(container)?.();\n            window.removeEventListener(\"resize\", scrollListener);\n        }\n    };\n}\n\nexport { scrollInfo };\n", "import { supportsScrollTimeline } from 'motion-dom';\nimport { scrollInfo } from '../track.mjs';\n\nconst timelineCache = new Map();\nfunction scrollTimelineFallback(options) {\n    const currentTime = { value: 0 };\n    const cancel = scrollInfo((info) => {\n        currentTime.value = info[options.axis].progress * 100;\n    }, options);\n    return { currentTime, cancel };\n}\nfunction getTimeline({ source, container, ...options }) {\n    const { axis } = options;\n    if (source)\n        container = source;\n    const containerCache = timelineCache.get(container) ?? new Map();\n    timelineCache.set(container, containerCache);\n    const targetKey = options.target ?? \"self\";\n    const targetCache = containerCache.get(targetKey) ?? {};\n    const axisKey = axis + (options.offset ?? []).join(\",\");\n    if (!targetCache[axisKey]) {\n        targetCache[axisKey] =\n            !options.target && supportsScrollTimeline()\n                ? new ScrollTimeline({ source: container, axis })\n                : scrollTimelineFallback({ container, ...options });\n    }\n    return targetCache[axisKey];\n}\n\nexport { getTimeline };\n", "import { observeTimeline } from 'motion-dom';\nimport { getTimeline } from './utils/get-timeline.mjs';\n\nfunction attachToAnimation(animation, options) {\n    const timeline = getTimeline(options);\n    return animation.attachTimeline({\n        timeline: options.target ? undefined : timeline,\n        observe: (valueAnimation) => {\n            valueAnimation.pause();\n            return observeTimeline((progress) => {\n                valueAnimation.time =\n                    valueAnimation.iterationDuration * progress;\n            }, timeline);\n        },\n    });\n}\n\nexport { attachToAnimation };\n", "import { observeTimeline } from 'motion-dom';\nimport { scrollInfo } from './track.mjs';\nimport { getTimeline } from './utils/get-timeline.mjs';\n\n/**\n * If the onScroll function has two arguments, it's expecting\n * more specific information about the scroll from scrollInfo.\n */\nfunction isOnScrollWithInfo(onScroll) {\n    return onScroll.length === 2;\n}\nfunction attachToFunction(onScroll, options) {\n    if (isOnScrollWithInfo(onScroll)) {\n        return scrollInfo((info) => {\n            onScroll(info[options.axis].progress, info);\n        }, options);\n    }\n    else {\n        return observeTimeline(onScroll, getTimeline(options));\n    }\n}\n\nexport { attachToFunction };\n", "import { noop } from 'motion-utils';\nimport { attachToAnimation } from './attach-animation.mjs';\nimport { attachToFunction } from './attach-function.mjs';\n\nfunction scroll(onScroll, { axis = \"y\", container = document.scrollingElement, ...options } = {}) {\n    if (!container)\n        return noop;\n    const optionsWithDefaults = { axis, container, ...options };\n    return typeof onScroll === \"function\"\n        ? attachToFunction(onScroll, optionsWithDefaults)\n        : attachToAnimation(onScroll, optionsWithDefaults);\n}\n\nexport { scroll };\n", "import { warnOnce } from 'motion-utils';\nimport { useScroll } from '../use-scroll.mjs';\n\n/**\n * @deprecated useElementScroll is deprecated. Convert to useScroll({ container: ref })\n */\nfunction useElementScroll(ref) {\n    if (process.env.NODE_ENV === \"development\") {\n        warnOnce(false, \"useElementScroll is deprecated. Convert to useScroll({ container: ref }).\");\n    }\n    return useScroll({ container: ref });\n}\n\nexport { useElementScroll };\n", "import { warnOnce } from 'motion-utils';\nimport { useScroll } from '../use-scroll.mjs';\n\n/**\n * @deprecated useViewportScroll is deprecated. Convert to useScroll()\n */\nfunction useViewportScroll() {\n    if (process.env.NODE_ENV !== \"production\") {\n        warnOnce(false, \"useViewportScroll is deprecated. Convert to useScroll().\");\n    }\n    return useScroll();\n}\n\nexport { useViewportScroll };\n", "\"use client\";\nimport { motionValue } from 'motion-dom';\nimport { useContext, useState, useEffect } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    const value = useConstant(() => motionValue(initial));\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    const { isStatic } = useContext(MotionConfigContext);\n    if (isStatic) {\n        const [, setLatest] = useState(initial);\n        useEffect(() => value.on(\"change\", setLatest), []);\n    }\n    return value;\n}\n\nexport { useMotionValue };\n", "\"use client\";\nimport { cancelFrame, frame } from 'motion-dom';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\nimport { useMotionValue } from './use-motion-value.mjs';\n\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */\n    const value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */\n    const updateValue = () => value.set(combineValues());\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */\n    updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */\n    useIsomorphicLayoutEffect(() => {\n        const scheduleUpdate = () => frame.preRender(updateValue, false, true);\n        const subscriptions = values.map((v) => v.on(\"change\", scheduleUpdate));\n        return () => {\n            subscriptions.forEach((unsubscribe) => unsubscribe());\n            cancelFrame(updateValue);\n        };\n    });\n    return value;\n}\n\nexport { useCombineMotionValues };\n", "\"use client\";\nimport { isMotionValue } from 'motion-dom';\nimport { useCombineMotionValues } from './use-combine-values.mjs';\n\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from \"framer-motion\"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */\nfunction useMotionTemplate(fragments, ...values) {\n    /**\n     * Create a function that will build a string from the latest motion values.\n     */\n    const numFragments = fragments.length;\n    function buildValue() {\n        let output = ``;\n        for (let i = 0; i < numFragments; i++) {\n            output += fragments[i];\n            const value = values[i];\n            if (value) {\n                output += isMotionValue(value) ? value.get() : value;\n            }\n        }\n        return output;\n    }\n    return useCombineMotionValues(values.filter(isMotionValue), buildValue);\n}\n\nexport { useMotionTemplate };\n", "\"use client\";\nimport { attachSpring, isMotionValue } from 'motion-dom';\nimport { useContext, useInsertionEffect } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useMotionValue } from './use-motion-value.mjs';\nimport { useTransform } from './use-transform.mjs';\n\nfunction useSpring(source, options = {}) {\n    const { isStatic } = useContext(MotionConfigContext);\n    const getFromSource = () => (isMotionValue(source) ? source.get() : source);\n    // isStatic will never change, allowing early hooks return\n    if (isStatic) {\n        return useTransform(getFromSource);\n    }\n    const value = useMotionValue(getFromSource());\n    useInsertionEffect(() => {\n        return attachSpring(value, source, options);\n    }, [value, JSON.stringify(options)]);\n    return value;\n}\n\nexport { useSpring };\n", "\"use client\";\nimport { collectMotionValues } from 'motion-dom';\nimport { useCombineMotionValues } from './use-combine-values.mjs';\n\nfunction useComputed(compute) {\n    /**\n     * Open session of collectMotionValues. Any MotionValue that calls get()\n     * will be saved into this array.\n     */\n    collectMotionValues.current = [];\n    compute();\n    const value = useCombineMotionValues(collectMotionValues.current, compute);\n    /**\n     * Synchronously close session of collectMotionValues.\n     */\n    collectMotionValues.current = undefined;\n    return value;\n}\n\nexport { useComputed };\n", "\"use client\";\nimport { transform } from 'motion-dom';\nimport { useConstant } from '../utils/use-constant.mjs';\nimport { useCombineMotionValues } from './use-combine-values.mjs';\nimport { useComputed } from './use-computed.mjs';\n\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n    if (typeof input === \"function\") {\n        return useComputed(input);\n    }\n    const transformer = typeof inputRangeOrTransformer === \"function\"\n        ? inputRangeOrTransformer\n        : transform(inputRangeOrTransformer, outputRange, options);\n    return Array.isArray(input)\n        ? useListTransform(input, transformer)\n        : useListTransform([input], ([latest]) => transformer(latest));\n}\nfunction useListTransform(values, transformer) {\n    const latest = useConstant(() => []);\n    return useCombineMotionValues(values, () => {\n        latest.length = 0;\n        const numValues = values.length;\n        for (let i = 0; i < numValues; i++) {\n            latest[i] = values[i].get();\n        }\n        return transformer(latest);\n    });\n}\n\nexport { useTransform };\n", "\"use client\";\nimport { frame, cancelFrame } from 'motion-dom';\nimport { useRef, useContext, useEffect } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\n\nfunction useAnimationFrame(callback) {\n    const initialTimestamp = useRef(0);\n    const { isStatic } = useContext(MotionConfigContext);\n    useEffect(() => {\n        if (isStatic)\n            return;\n        const provideTimeSinceStart = ({ timestamp, delta }) => {\n            if (!initialTimestamp.current)\n                initialTimestamp.current = timestamp;\n            callback(timestamp - initialTimestamp.current, delta);\n        };\n        frame.update(provideTimeSinceStart, true);\n        return () => cancelFrame(provideTimeSinceStart);\n    }, [callback]);\n}\n\nexport { useAnimationFrame };\n", "\"use client\";\nimport { useAnimationFrame } from '../utils/use-animation-frame.mjs';\nimport { useMotionValue } from './use-motion-value.mjs';\n\nfunction useTime() {\n    const time = useMotionValue(0);\n    useAnimationFrame((t) => time.set(t));\n    return time;\n}\n\nexport { useTime };\n", "\"use client\";\nimport { frame } from 'motion-dom';\nimport { useMotionValueEvent } from '../utils/use-motion-value-event.mjs';\nimport { useMotionValue } from './use-motion-value.mjs';\n\n/**\n * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.\n *\n * ```javascript\n * const x = useMotionValue(0)\n * const xVelocity = useVelocity(x)\n * const xAcceleration = useVelocity(xVelocity)\n * ```\n *\n * @public\n */\nfunction useVelocity(value) {\n    const velocity = useMotionValue(value.getVelocity());\n    const updateVelocity = () => {\n        const latest = value.getVelocity();\n        velocity.set(latest);\n        /**\n         * If we still have velocity, schedule an update for the next frame\n         * to keep checking until it is zero.\n         */\n        if (latest)\n            frame.update(updateVelocity);\n    };\n    useMotionValueEvent(value, \"change\", () => {\n        // Schedule an update to this value at the end of the current frame.\n        frame.update(updateVelocity, false, true);\n    });\n    return velocity;\n}\n\nexport { useVelocity };\n", "import { MotionValue, transformProps, acceleratedValues } from 'motion-dom';\n\nclass WillChangeMotionValue extends MotionValue {\n    constructor() {\n        super(...arguments);\n        this.isEnabled = false;\n    }\n    add(name) {\n        if (transformProps.has(name) || acceleratedValues.has(name)) {\n            this.isEnabled = true;\n            this.update();\n        }\n    }\n    update() {\n        this.set(this.isEnabled ? \"transform\" : \"auto\");\n    }\n}\n\nexport { WillChangeMotionValue };\n", "\"use client\";\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { WillChangeMotionValue } from './WillChangeMotionValue.mjs';\n\nfunction useWillChange() {\n    return useConstant(() => new WillChangeMotionValue(\"auto\"));\n}\n\nexport { useWillChange };\n", "\"use client\";\nimport { warnOnce } from 'motion-utils';\nimport { useState } from 'react';\nimport { initPrefersReducedMotion } from './index.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from './state.mjs';\n\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\nfunction useReducedMotion() {\n    /**\n     * Lazy initialisation of prefersReducedMotion\n     */\n    !hasReducedMotionListener.current && initPrefersReducedMotion();\n    const [shouldReduceMotion] = useState(prefersReducedMotion.current);\n    if (process.env.NODE_ENV !== \"production\") {\n        warnOnce(shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\", \"reduced-motion-disabled\");\n    }\n    /**\n     * TODO See if people miss automatically updating shouldReduceMotion setting\n     */\n    return shouldReduceMotion;\n}\n\nexport { useReducedMotion };\n", "\"use client\";\nimport { useContext } from 'react';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { useReducedMotion } from './use-reduced-motion.mjs';\n\nfunction useReducedMotionConfig() {\n    const reducedMotionPreference = useReducedMotion();\n    const { reducedMotion } = useContext(MotionConfigContext);\n    if (reducedMotion === \"never\") {\n        return false;\n    }\n    else if (reducedMotion === \"always\") {\n        return true;\n    }\n    else {\n        return reducedMotionPreference;\n    }\n}\n\nexport { useReducedMotionConfig };\n", "import { invariant } from 'motion-utils';\nimport { setTarget } from '../../render/utils/setters.mjs';\nimport { animateVisualElement } from '../interfaces/visual-element.mjs';\n\nfunction stopAnimation(visualElement) {\n    visualElement.values.forEach((value) => value.stop());\n}\nfunction setVariants(visualElement, variantLabels) {\n    const reversedLabels = [...variantLabels].reverse();\n    reversedLabels.forEach((key) => {\n        const variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        if (visualElement.variantChildren) {\n            visualElement.variantChildren.forEach((child) => {\n                setVariants(child, variantLabels);\n            });\n        }\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    let hasMounted = false;\n    /**\n     * A collection of linked component animation controls.\n     */\n    const subscribers = new Set();\n    const controls = {\n        subscribe(visualElement) {\n            subscribers.add(visualElement);\n            return () => void subscribers.delete(visualElement);\n        },\n        start(definition, transitionOverride) {\n            invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            const animations = [];\n            subscribers.forEach((visualElement) => {\n                animations.push(animateVisualElement(visualElement, definition, {\n                    transitionOverride,\n                }));\n            });\n            return Promise.all(animations);\n        },\n        set(definition) {\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach((visualElement) => {\n                setValues(visualElement, definition);\n            });\n        },\n        stop() {\n            subscribers.forEach((visualElement) => {\n                stopAnimation(visualElement);\n            });\n        },\n        mount() {\n            hasMounted = true;\n            return () => {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\nexport { animationControls, setValues };\n", "function isDOMKeyframes(keyframes) {\n    return typeof keyframes === \"object\" && !Array.isArray(keyframes);\n}\n\nexport { isDOMKeyframes };\n", "import { resolveElements } from 'motion-dom';\nimport { isDOMKeyframes } from '../utils/is-dom-keyframes.mjs';\n\nfunction resolveSubjects(subject, keyframes, scope, selectorCache) {\n    if (typeof subject === \"string\" && isDOMKeyframes(keyframes)) {\n        return resolveElements(subject, scope, selectorCache);\n    }\n    else if (subject instanceof NodeList) {\n        return Array.from(subject);\n    }\n    else if (Array.isArray(subject)) {\n        return subject;\n    }\n    else {\n        return [subject];\n    }\n}\n\nexport { resolveSubjects };\n", "function calculateRepeatDuration(duration, repeat, _repeatDelay) {\n    return duration * (repeat + 1);\n}\n\nexport { calculateRepeatDuration };\n", "/**\n * Given a absolute or relative time definition and current/prev time state of the sequence,\n * calculate an absolute time for the next keyframes.\n */\nfunction calcNextTime(current, next, prev, labels) {\n    if (typeof next === \"number\") {\n        return next;\n    }\n    else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n        return Math.max(0, current + parseFloat(next));\n    }\n    else if (next === \"<\") {\n        return prev;\n    }\n    else if (next.startsWith(\"<\")) {\n        return Math.max(0, prev + parseFloat(next.slice(1)));\n    }\n    else {\n        return labels.get(next) ?? current;\n    }\n}\n\nexport { calcNextTime };\n", "import { mixNumber } from 'motion-dom';\nimport { getEasingForSegment, removeItem } from 'motion-utils';\n\nfunction eraseKeyframes(sequence, startTime, endTime) {\n    for (let i = 0; i < sequence.length; i++) {\n        const keyframe = sequence[i];\n        if (keyframe.at > startTime && keyframe.at < endTime) {\n            removeItem(sequence, keyframe);\n            // If we remove this item we have to push the pointer back one\n            i--;\n        }\n    }\n}\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\n    /**\n     * Erase every existing value between currentTime and targetTime,\n     * this will essentially splice this timeline into any currently\n     * defined ones.\n     */\n    eraseKeyframes(sequence, startTime, endTime);\n    for (let i = 0; i < keyframes.length; i++) {\n        sequence.push({\n            value: keyframes[i],\n            at: mixNumber(startTime, endTime, offset[i]),\n            easing: getEasingForSegment(easing, i),\n        });\n    }\n}\n\nexport { addKeyframes, eraseKeyframes };\n", "/**\n * Take an array of times that represent repeated keyframes. For instance\n * if we have original times of [0, 0.5, 1] then our repeated times will\n * be [0, 0.5, 1, 1, 1.5, 2]. Loop over the times and scale them back\n * down to a 0-1 scale.\n */\nfunction normalizeTimes(times, repeat) {\n    for (let i = 0; i < times.length; i++) {\n        times[i] = times[i] / (repeat + 1);\n    }\n}\n\nexport { normalizeTimes };\n", "function compareByTime(a, b) {\n    if (a.at === b.at) {\n        if (a.value === null)\n            return 1;\n        if (b.value === null)\n            return -1;\n        return 0;\n    }\n    else {\n        return a.at - b.at;\n    }\n}\n\nexport { compareByTime };\n", "import { isMotionValue, defaultOffset, isGenerator, createGeneratorEasing, fillOffset } from 'motion-dom';\nimport { progress, secondsToMilliseconds, invariant, getEasingForSegment } from 'motion-utils';\nimport { resolveSubjects } from '../animate/resolve-subjects.mjs';\nimport { calculateRepeatDuration } from './utils/calc-repeat-duration.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { normalizeTimes } from './utils/normalize-times.mjs';\nimport { compareByTime } from './utils/sort.mjs';\n\nconst defaultSegmentEasing = \"easeInOut\";\nconst MAX_REPEAT = 20;\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = \"keyframes\", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay = typeof delay === \"function\"\n                ? delay(elementIndex, numSubjects)\n                : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length;\n            const createGenerator = isGenerator(type)\n                ? type\n                : generators?.[type || \"keyframes\"];\n            if (numKeyframes <= 2 && createGenerator) {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100;\n                if (numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = { ...remainingTransition };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration ?? (duration = defaultDuration);\n            const startTime = currentTime + calculatedDelay;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Handle repeat options\n             */\n            if (repeat) {\n                invariant(repeat < MAX_REPEAT, \"Repeat count too high, must be less than 20\", \"repeat-count-high\");\n                duration = calculateRepeatDuration(duration, repeat);\n                const originalKeyframes = [...valueKeyframesAsList];\n                const originalTimes = [...times];\n                ease = Array.isArray(ease) ? [...ease] : [ease];\n                const originalEase = [...ease];\n                for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {\n                    valueKeyframesAsList.push(...originalKeyframes);\n                    for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {\n                        times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));\n                        ease.push(keyframeIndex === 0\n                            ? \"linear\"\n                            : getEasingForSegment(originalEase, keyframeIndex - 1));\n                    }\n                }\n                normalizeTimes(times, repeat);\n            }\n            const targetTime = startTime + duration;\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            const subjects = resolveSubjects(subject, keyframes, scope, elementCache);\n            const numSubjects = subjects.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const thisSubject = subjects[subjectIndex];\n                const subjectSequence = getSubjectSequence(thisSubject, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);\n                }\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition && transition[key]\n        ? {\n            ...transition,\n            ...transition[key],\n        }\n        : { ...transition };\n}\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\n\nexport { createAnimationsFromSequence, getValueTransition };\n", "import { createBox } from '../../projection/geometry/models.mjs';\nimport { VisualElement } from '../VisualElement.mjs';\n\nfunction isObjectKey(key, object) {\n    return key in object;\n}\nclass ObjectVisualElement extends VisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = \"object\";\n    }\n    readValueFromInstance(instance, key) {\n        if (isObjectKey(key, instance)) {\n            const value = instance[key];\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    getBaseTargetFromProps() {\n        return undefined;\n    }\n    removeValueFromRenderState(key, renderState) {\n        delete renderState.output[key];\n    }\n    measureInstanceViewportBox() {\n        return createBox();\n    }\n    build(renderState, latestValues) {\n        Object.assign(renderState.output, latestValues);\n    }\n    renderInstance(instance, { output }) {\n        Object.assign(instance, output);\n    }\n    sortInstanceNodePosition() {\n        return 0;\n    }\n}\n\nexport { ObjectVisualElement };\n", "import { isSVGElement, isSVGSVGElement } from 'motion-dom';\nimport { HTMLVisualElement } from '../../render/html/HTMLVisualElement.mjs';\nimport { ObjectVisualElement } from '../../render/object/ObjectVisualElement.mjs';\nimport { visualElementStore } from '../../render/store.mjs';\nimport { SVGVisualElement } from '../../render/svg/SVGVisualElement.mjs';\n\nfunction createDOMVisualElement(element) {\n    const options = {\n        presenceContext: null,\n        props: {},\n        visualState: {\n            renderState: {\n                transform: {},\n                transformOrigin: {},\n                style: {},\n                vars: {},\n                attrs: {},\n            },\n            latestValues: {},\n        },\n    };\n    const node = isSVGElement(element) && !isSVGSVGElement(element)\n        ? new SVGVisualElement(options)\n        : new HTMLVisualElement(options);\n    node.mount(element);\n    visualElementStore.set(element, node);\n}\nfunction createObjectVisualElement(subject) {\n    const options = {\n        presenceContext: null,\n        props: {},\n        visualState: {\n            renderState: {\n                output: {},\n            },\n            latestValues: {},\n        },\n    };\n    const node = new ObjectVisualElement(options);\n    node.mount(subject);\n    visualElementStore.set(subject, node);\n}\n\nexport { createDOMVisualElement, createObjectVisualElement };\n", "import { isMotionValue } from 'motion-dom';\nimport { invariant } from 'motion-utils';\nimport { visualElementStore } from '../../render/store.mjs';\nimport { animateTarget } from '../interfaces/visual-element-target.mjs';\nimport { createDOMVisualElement, createObjectVisualElement } from '../utils/create-visual-element.mjs';\nimport { isDOMKeyframes } from '../utils/is-dom-keyframes.mjs';\nimport { resolveSubjects } from './resolve-subjects.mjs';\nimport { animateSingleValue } from './single-value.mjs';\n\nfunction isSingleValue(subject, keyframes) {\n    return (isMotionValue(subject) ||\n        typeof subject === \"number\" ||\n        (typeof subject === \"string\" && !isDOMKeyframes(keyframes)));\n}\n/**\n * Implementation\n */\nfunction animateSubject(subject, keyframes, options, scope) {\n    const animations = [];\n    if (isSingleValue(subject, keyframes)) {\n        animations.push(animateSingleValue(subject, isDOMKeyframes(keyframes)\n            ? keyframes.default || keyframes\n            : keyframes, options ? options.default || options : options));\n    }\n    else {\n        const subjects = resolveSubjects(subject, keyframes, scope);\n        const numSubjects = subjects.length;\n        invariant(Boolean(numSubjects), \"No valid elements provided.\", \"no-valid-elements\");\n        for (let i = 0; i < numSubjects; i++) {\n            const thisSubject = subjects[i];\n            invariant(thisSubject !== null, \"You're trying to perform an animation on null. Ensure that selectors are correctly finding elements and refs are correctly hydrated.\", \"animate-null\");\n            const createVisualElement = thisSubject instanceof Element\n                ? createDOMVisualElement\n                : createObjectVisualElement;\n            if (!visualElementStore.has(thisSubject)) {\n                createVisualElement(thisSubject);\n            }\n            const visualElement = visualElementStore.get(thisSubject);\n            const transition = { ...options };\n            /**\n             * Resolve stagger function if provided.\n             */\n            if (\"delay\" in transition &&\n                typeof transition.delay === \"function\") {\n                transition.delay = transition.delay(i, numSubjects);\n            }\n            animations.push(...animateTarget(visualElement, { ...keyframes, transition }, {}));\n        }\n    }\n    return animations;\n}\n\nexport { animateSubject };\n", "import { spring } from 'motion-dom';\nimport { createAnimationsFromSequence } from '../sequence/create.mjs';\nimport { animateSubject } from './subject.mjs';\n\nfunction animateSequence(sequence, options, scope) {\n    const animations = [];\n    const animationDefinitions = createAnimationsFromSequence(sequence, options, scope, { spring });\n    animationDefinitions.forEach(({ keyframes, transition }, subject) => {\n        animations.push(...animateSubject(subject, keyframes, transition));\n    });\n    return animations;\n}\n\nexport { animateSequence };\n", "import { GroupAnimationWithThen } from 'motion-dom';\nimport { removeItem } from 'motion-utils';\nimport { animateSequence } from './sequence.mjs';\nimport { animateSubject } from './subject.mjs';\n\nfunction isSequence(value) {\n    return Array.isArray(value) && value.some(Array.isArray);\n}\n/**\n * Creates an animation function that is optionally scoped\n * to a specific element.\n */\nfunction createScopedAnimate(scope) {\n    /**\n     * Implementation\n     */\n    function scopedAnimate(subjectOrSequence, optionsOrKeyframes, options) {\n        let animations = [];\n        let animationOnComplete;\n        if (isSequence(subjectOrSequence)) {\n            animations = animateSequence(subjectOrSequence, optionsOrKeyframes, scope);\n        }\n        else {\n            // Extract top-level onComplete so it doesn't get applied per-value\n            const { onComplete, ...rest } = options || {};\n            if (typeof onComplete === \"function\") {\n                animationOnComplete = onComplete;\n            }\n            animations = animateSubject(subjectOrSequence, optionsOrKeyframes, rest, scope);\n        }\n        const animation = new GroupAnimationWithThen(animations);\n        if (animationOnComplete) {\n            animation.finished.then(animationOnComplete);\n        }\n        if (scope) {\n            scope.animations.push(animation);\n            animation.finished.then(() => {\n                removeItem(scope.animations, animation);\n            });\n        }\n        return animation;\n    }\n    return scopedAnimate;\n}\nconst animate = createScopedAnimate();\n\nexport { animate, createScopedAnimate };\n", "\"use client\";\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\nimport { createScopedAnimate } from '../animate/index.mjs';\n\nfunction useAnimate() {\n    const scope = useConstant(() => ({\n        current: null, // Will be hydrated by React\n        animations: [],\n    }));\n    const animate = useConstant(() => createScopedAnimate(scope));\n    useUnmountEffect(() => {\n        scope.animations.forEach((animation) => animation.stop());\n        scope.animations.length = 0;\n    });\n    return [scope, animate];\n}\n\nexport { useAnimate };\n", "import { resolveElements, getValueTransition, getAnimationMap, animationMapKey, getComputedStyle, fillWildcards, applyPxDefaults, NativeAnimation } from 'motion-dom';\nimport { invariant, secondsToMilliseconds } from 'motion-utils';\n\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n    const elements = resolveElements(elementOrSelector, scope);\n    const numElements = elements.length;\n    invariant(Boolean(numElements), \"No valid elements provided.\", \"no-valid-elements\");\n    /**\n     * WAAPI doesn't support interrupting animations.\n     *\n     * Therefore, starting animations requires a three-step process:\n     * 1. Stop existing animations (write styles to DOM)\n     * 2. Resolve keyframes (read styles from DOM)\n     * 3. Create new animations (write styles to DOM)\n     *\n     * The hybrid `animate()` function uses AsyncAnimation to resolve\n     * keyframes before creating new animations, which removes style\n     * thrashing. Here, we have much stricter filesize constraints.\n     * Therefore we do this in a synchronous way that ensures that\n     * at least within `animate()` calls there is no style thrashing.\n     *\n     * In the motion-native-animate-mini-interrupt benchmark this\n     * was 80% faster than a single loop.\n     */\n    const animationDefinitions = [];\n    /**\n     * Step 1: Build options and stop existing animations (write)\n     */\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i];\n        const elementTransition = { ...options };\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof elementTransition.delay === \"function\") {\n            elementTransition.delay = elementTransition.delay(i, numElements);\n        }\n        for (const valueName in keyframes) {\n            let valueKeyframes = keyframes[valueName];\n            if (!Array.isArray(valueKeyframes)) {\n                valueKeyframes = [valueKeyframes];\n            }\n            const valueOptions = {\n                ...getValueTransition(elementTransition, valueName),\n            };\n            valueOptions.duration && (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));\n            valueOptions.delay && (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));\n            /**\n             * If there's an existing animation playing on this element then stop it\n             * before creating a new one.\n             */\n            const map = getAnimationMap(element);\n            const key = animationMapKey(valueName, valueOptions.pseudoElement || \"\");\n            const currentAnimation = map.get(key);\n            currentAnimation && currentAnimation.stop();\n            animationDefinitions.push({\n                map,\n                key,\n                unresolvedKeyframes: valueKeyframes,\n                options: {\n                    ...valueOptions,\n                    element,\n                    name: valueName,\n                    allowFlatten: !elementTransition.type && !elementTransition.ease,\n                },\n            });\n        }\n    }\n    /**\n     * Step 2: Resolve keyframes (read)\n     */\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { unresolvedKeyframes, options: animationOptions } = animationDefinitions[i];\n        const { element, name, pseudoElement } = animationOptions;\n        if (!pseudoElement && unresolvedKeyframes[0] === null) {\n            unresolvedKeyframes[0] = getComputedStyle(element, name);\n        }\n        fillWildcards(unresolvedKeyframes);\n        applyPxDefaults(unresolvedKeyframes, name);\n        /**\n         * If we only have one keyframe, explicitly read the initial keyframe\n         * from the computed style. This is to ensure consistency with WAAPI behaviour\n         * for restarting animations, for instance .play() after finish, when it\n         * has one vs two keyframes.\n         */\n        if (!pseudoElement && unresolvedKeyframes.length < 2) {\n            unresolvedKeyframes.unshift(getComputedStyle(element, name));\n        }\n        animationOptions.keyframes = unresolvedKeyframes;\n    }\n    /**\n     * Step 3: Create new animations (write)\n     */\n    const animations = [];\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { map, key, options: animationOptions } = animationDefinitions[i];\n        const animation = new NativeAnimation(animationOptions);\n        map.set(key, animation);\n        animation.finished.finally(() => map.delete(key));\n        animations.push(animation);\n    }\n    return animations;\n}\n\nexport { animateElements };\n", "import { GroupAnimationWithThen } from 'motion-dom';\nimport { animateElements } from './animate-elements.mjs';\n\nconst createScopedWaapiAnimate = (scope) => {\n    function scopedAnimate(elementOrSelector, keyframes, options) {\n        return new GroupAnimationWithThen(animateElements(elementOrSelector, keyframes, options, scope));\n    }\n    return scopedAnimate;\n};\nconst animateMini = /*@__PURE__*/ createScopedWaapiAnimate();\n\nexport { animateMini, createScopedWaapiAnimate };\n", "\"use client\";\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\nimport { createScopedWaapiAnimate } from '../animators/waapi/animate-style.mjs';\n\nfunction useAnimateMini() {\n    const scope = useConstant(() => ({\n        current: null, // Will be hydrated by React\n        animations: [],\n    }));\n    const animate = useConstant(() => createScopedWaapiAnimate(scope));\n    useUnmountEffect(() => {\n        scope.animations.forEach((animation) => animation.stop());\n    });\n    return [scope, animate];\n}\n\nexport { useAnimateMini };\n", "\"use client\";\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { animationControls } from './animation-controls.mjs';\n\n/**\n * Creates `LegacyAnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `LegacyAnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimationControls() {\n    const controls = useConstant(animationControls);\n    useIsomorphicLayoutEffect(controls.mount, []);\n    return controls;\n}\nconst useAnimation = useAnimationControls;\n\nexport { useAnimation, useAnimationControls };\n", "\"use client\";\nimport { useContext } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\n\nfunction usePresenceData() {\n    const context = useContext(PresenceContext);\n    return context ? context.custom : undefined;\n}\n\nexport { usePresenceData };\n", "\"use client\";\nimport { useEffect } from 'react';\nimport { addDomEvent } from './add-dom-event.mjs';\n\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\nfunction useDomEvent(ref, eventName, handler, options) {\n    useEffect(() => {\n        const element = ref.current;\n        if (handler && element) {\n            return addDomEvent(element, eventName, handler, options);\n        }\n    }, [ref, eventName, handler, options]);\n}\n\nexport { useDomEvent };\n", "import { useConstant } from '../../utils/use-constant.mjs';\n\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nclass DragControls {\n    constructor() {\n        this.componentControls = new Set();\n    }\n    /**\n     * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.\n     *\n     * @internal\n     */\n    subscribe(controls) {\n        this.componentControls.add(controls);\n        return () => this.componentControls.delete(controls);\n    }\n    /**\n     * Start a drag gesture on every `motion` component that has this set of drag controls\n     * passed into it via the `dragControls` prop.\n     *\n     * ```jsx\n     * dragControls.start(e, {\n     *   snapToCursor: true\n     * })\n     * ```\n     *\n     * @param event - PointerEvent\n     * @param options - Options\n     *\n     * @public\n     */\n    start(event, options) {\n        this.componentControls.forEach((controls) => {\n            controls.start(event.nativeEvent || event, options);\n        });\n    }\n    /**\n     * Cancels a drag gesture.\n     *\n     * ```jsx\n     * dragControls.cancel()\n     * ```\n     *\n     * @public\n     */\n    cancel() {\n        this.componentControls.forEach((controls) => {\n            controls.cancel();\n        });\n    }\n    /**\n     * Stops a drag gesture.\n     *\n     * ```jsx\n     * dragControls.stop()\n     * ```\n     *\n     * @public\n     */\n    stop() {\n        this.componentControls.forEach((controls) => {\n            controls.stop();\n        });\n    }\n}\nconst createDragControls = () => new DragControls();\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component's `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag=\"x\" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nfunction useDragControls() {\n    return useConstant(createDragControls);\n}\n\nexport { DragControls, useDragControls };\n", "import { motionComponentSymbol } from './symbol.mjs';\n\n/**\n * Checks if a component is a `motion` component.\n */\nfunction isMotionComponent(component) {\n    return (component !== null &&\n        typeof component === \"object\" &&\n        motionComponentSymbol in component);\n}\n\nexport { isMotionComponent };\n", "import { isMotionComponent } from './is-motion-component.mjs';\nimport { motionComponentSymbol } from './symbol.mjs';\n\n/**\n * Unwraps a `motion` component and returns either a string for `motion.div` or\n * the React component for `motion(Component)`.\n *\n * If the component is not a `motion` component it returns undefined.\n */\nfunction unwrapMotionComponent(component) {\n    if (isMotionComponent(component)) {\n        return component[motionComponentSymbol];\n    }\n    return undefined;\n}\n\nexport { unwrapMotionComponent };\n", "import { rootProjectionNode } from './node/HTMLProjectionNode.mjs';\n\nfunction useInstantLayoutTransition() {\n    return startTransition;\n}\nfunction startTransition(callback) {\n    if (!rootProjectionNode.current)\n        return;\n    rootProjectionNode.current.isUpdating = false;\n    rootProjectionNode.current.blockUpdate();\n    callback && callback();\n}\n\nexport { useInstantLayoutTransition };\n", "import { useCallback } from 'react';\nimport { rootProjectionNode } from './node/HTMLProjectionNode.mjs';\n\nfunction useResetProjection() {\n    const reset = useCallback(() => {\n        const root = rootProjectionNode.current;\n        if (!root)\n            return;\n        root.resetTree();\n    }, []);\n    return reset;\n}\n\nexport { useResetProjection };\n", "\"use client\";\nimport { wrap } from 'motion-utils';\nimport { useRef, useState, useCallback } from 'react';\n\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from \"react\"\n * import { motion, useCycle } from \"framer-motion\"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\nfunction useCycle(...items) {\n    const index = useRef(0);\n    const [item, setItem] = useState(items[index.current]);\n    const runCycle = useCallback((next) => {\n        index.current =\n            typeof next !== \"number\"\n                ? wrap(0, items.length, index.current + 1)\n                : next;\n        setItem(items[index.current]);\n    }, \n    // The array will change on each call, but by putting items.length at\n    // the front of this array, we guarantee the dependency comparison will match up\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [items.length, ...items]);\n    return [item, runCycle];\n}\n\nexport { useCycle };\n", "\"use client\";\nimport { useState, useEffect } from 'react';\nimport { inView } from '../render/dom/viewport/index.mjs';\n\nfunction useInView(ref, { root, margin, amount, once = false, initial = false, } = {}) {\n    const [isInView, setInView] = useState(initial);\n    useEffect(() => {\n        if (!ref.current || (once && isInView))\n            return;\n        const onEnter = () => {\n            setInView(true);\n            return once ? undefined : () => setInView(false);\n        };\n        const options = {\n            root: (root && root.current) || undefined,\n            margin,\n            amount,\n        };\n        return inView(ref.current, onEnter, options);\n    }, [root, ref, margin, once, amount]);\n    return isInView;\n}\n\nexport { useInView };\n", "import { resolveElements } from 'motion-dom';\n\nconst thresholds = {\n    some: 0,\n    all: 1,\n};\nfunction inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = \"some\" } = {}) {\n    const elements = resolveElements(elementOrSelector);\n    const activeIntersections = new WeakMap();\n    const onIntersectionChange = (entries) => {\n        entries.forEach((entry) => {\n            const onEnd = activeIntersections.get(entry.target);\n            /**\n             * If there's no change to the intersection, we don't need to\n             * do anything here.\n             */\n            if (entry.isIntersecting === Boolean(onEnd))\n                return;\n            if (entry.isIntersecting) {\n                const newOnEnd = onStart(entry.target, entry);\n                if (typeof newOnEnd === \"function\") {\n                    activeIntersections.set(entry.target, newOnEnd);\n                }\n                else {\n                    observer.unobserve(entry.target);\n                }\n            }\n            else if (typeof onEnd === \"function\") {\n                onEnd(entry);\n                activeIntersections.delete(entry.target);\n            }\n        });\n    };\n    const observer = new IntersectionObserver(onIntersectionChange, {\n        root,\n        rootMargin,\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount],\n    });\n    elements.forEach((element) => observer.observe(element));\n    return () => observer.disconnect();\n}\n\nexport { inView };\n", "\"use client\";\nimport { frame } from 'motion-dom';\nimport { MotionGlobalConfig } from 'motion-utils';\nimport { useRef, useEffect } from 'react';\nimport { useInstantLayoutTransition } from '../projection/use-instant-layout-transition.mjs';\nimport { useForceUpdate } from './use-force-update.mjs';\n\nfunction useInstantTransition() {\n    const [forceUpdate, forcedRenderCount] = useForceUpdate();\n    const startInstantLayoutTransition = useInstantLayoutTransition();\n    const unlockOnFrameRef = useRef(-1);\n    useEffect(() => {\n        /**\n         * Unblock after two animation frames, otherwise this will unblock too soon.\n         */\n        frame.postRender(() => frame.postRender(() => {\n            /**\n             * If the callback has been called again after the effect\n             * triggered this 2 frame delay, don't unblock animations. This\n             * prevents the previous effect from unblocking the current\n             * instant transition too soon. This becomes more likely when\n             * used in conjunction with React.startTransition().\n             */\n            if (forcedRenderCount !== unlockOnFrameRef.current)\n                return;\n            MotionGlobalConfig.instantAnimations = false;\n        }));\n    }, [forcedRenderCount]);\n    return (callback) => {\n        startInstantLayoutTransition(() => {\n            MotionGlobalConfig.instantAnimations = true;\n            forceUpdate();\n            callback();\n            unlockOnFrameRef.current = forcedRenderCount + 1;\n        });\n    };\n}\nfunction disableInstantTransitions() {\n    MotionGlobalConfig.instantAnimations = false;\n}\n\nexport { disableInstantTransitions, useInstantTransition };\n", "\"use client\";\nimport { useState, useEffect } from 'react';\n\nfunction usePageInView() {\n    const [isInView, setIsInView] = useState(true);\n    useEffect(() => {\n        const handleVisibilityChange = () => setIsInView(!document.hidden);\n        if (document.hidden) {\n            handleVisibilityChange();\n        }\n        document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n        return () => {\n            document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n        };\n    }, []);\n    return isInView;\n}\n\nexport { usePageInView };\n", "const appearAnimationStore = new Map();\nconst appearComplete = new Map();\n\nexport { appearAnimationStore, appearComplete };\n", "import { transformProps } from 'motion-dom';\n\nconst appearStoreId = (elementId, valueName) => {\n    const key = transformProps.has(valueName) ? \"transform\" : valueName;\n    return `${elementId}: ${key}`;\n};\n\nexport { appearStoreId };\n", "import { appearAnimationStore } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\n\nfunction handoffOptimizedAppearAnimation(elementId, valueName, frame) {\n    const storeId = appearStoreId(elementId, valueName);\n    const optimisedAnimation = appearAnimationStore.get(storeId);\n    if (!optimisedAnimation) {\n        return null;\n    }\n    const { animation, startTime } = optimisedAnimation;\n    function cancelAnimation() {\n        window.MotionCancelOptimisedAnimation?.(elementId, valueName, frame);\n    }\n    /**\n     * We can cancel the animation once it's finished now that we've synced\n     * with Motion.\n     *\n     * Prefer onfinish over finished as onfinish is backwards compatible with\n     * older browsers.\n     */\n    animation.onfinish = cancelAnimation;\n    if (startTime === null || window.MotionHandoffIsComplete?.(elementId)) {\n        /**\n         * If the startTime is null, this animation is the Paint Ready detection animation\n         * and we can cancel it immediately without handoff.\n         *\n         * Or if we've already handed off the animation then we're now interrupting it.\n         * In which case we need to cancel it.\n         */\n        cancelAnimation();\n        return null;\n    }\n    else {\n        return startTime;\n    }\n}\n\nexport { handoffOptimizedAppearAnimation };\n", "import { startWaapiAnimation } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { optimizedAppearDataId } from './data-id.mjs';\nimport { getOptimisedAppearId } from './get-appear-id.mjs';\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\nimport { appearAnimationStore, appearComplete } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\n\n/**\n * A single time to use across all animations to manually set startTime\n * and ensure they're all in sync.\n */\nlet startFrameTime;\n/**\n * A dummy animation to detect when Chrome is ready to start\n * painting the page and hold off from triggering the real animation\n * until then. We only need one animation to detect paint ready.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n */\nlet readyAnimation;\n/**\n * Keep track of animations that were suspended vs cancelled so we\n * can easily resume them when we're done measuring layout.\n */\nconst suspendedAnimations = new Set();\nfunction resumeSuspendedAnimations() {\n    suspendedAnimations.forEach((data) => {\n        data.animation.play();\n        data.animation.startTime = data.startTime;\n    });\n    suspendedAnimations.clear();\n}\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n    // Prevent optimised appear animations if Motion has already started animating.\n    if (window.MotionIsMounted) {\n        return;\n    }\n    const id = element.dataset[optimizedAppearDataId];\n    if (!id)\n        return;\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n    const storeId = appearStoreId(id, name);\n    if (!readyAnimation) {\n        readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]], \n        /**\n         * 10 secs is basically just a super-safe duration to give Chrome\n         * long enough to get the animation ready.\n         */\n        { duration: 10000, ease: \"linear\" });\n        appearAnimationStore.set(storeId, {\n            animation: readyAnimation,\n            startTime: null,\n        });\n        /**\n         * If there's no readyAnimation then there's been no instantiation\n         * of handoff animations.\n         */\n        window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n        window.MotionHasOptimisedAnimation = (elementId, valueName) => {\n            if (!elementId)\n                return false;\n            /**\n             * Keep a map of elementIds that have started animating. We check\n             * via ID instead of Element because of hydration errors and\n             * pre-hydration checks. We also actively record IDs as they start\n             * animating rather than simply checking for data-appear-id as\n             * this attrbute might be present but not lead to an animation, for\n             * instance if the element's appear animation is on a different\n             * breakpoint.\n             */\n            if (!valueName) {\n                return appearComplete.has(elementId);\n            }\n            const animationId = appearStoreId(elementId, valueName);\n            return Boolean(appearAnimationStore.get(animationId));\n        };\n        window.MotionHandoffMarkAsComplete = (elementId) => {\n            if (appearComplete.has(elementId)) {\n                appearComplete.set(elementId, true);\n            }\n        };\n        window.MotionHandoffIsComplete = (elementId) => {\n            return appearComplete.get(elementId) === true;\n        };\n        /**\n         * We only need to cancel transform animations as\n         * they're the ones that will interfere with the\n         * layout animation measurements.\n         */\n        window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\n            const animationId = appearStoreId(elementId, valueName);\n            const data = appearAnimationStore.get(animationId);\n            if (!data)\n                return;\n            if (frame && canResume === undefined) {\n                /**\n                 * Wait until the end of the subsequent frame to cancel the animation\n                 * to ensure we don't remove the animation before the main thread has\n                 * had a chance to resolve keyframes and render.\n                 */\n                frame.postRender(() => {\n                    frame.postRender(() => {\n                        data.animation.cancel();\n                    });\n                });\n            }\n            else {\n                data.animation.cancel();\n            }\n            if (frame && canResume) {\n                suspendedAnimations.add(data);\n                frame.render(resumeSuspendedAnimations);\n            }\n            else {\n                appearAnimationStore.delete(animationId);\n                /**\n                 * If there are no more animations left, we can remove the cancel function.\n                 * This will let us know when we can stop checking for conflicting layout animations.\n                 */\n                if (!appearAnimationStore.size) {\n                    window.MotionCancelOptimisedAnimation = undefined;\n                }\n            }\n        };\n        window.MotionCheckAppearSync = (visualElement, valueName, value) => {\n            const appearId = getOptimisedAppearId(visualElement);\n            if (!appearId)\n                return;\n            const valueIsOptimised = window.MotionHasOptimisedAnimation?.(appearId, valueName);\n            const externalAnimationValue = visualElement.props.values?.[valueName];\n            if (!valueIsOptimised || !externalAnimationValue)\n                return;\n            const removeSyncCheck = value.on(\"change\", (latestValue) => {\n                if (externalAnimationValue.get() !== latestValue) {\n                    window.MotionCancelOptimisedAnimation?.(appearId, valueName);\n                    removeSyncCheck();\n                }\n            });\n            return removeSyncCheck;\n        };\n    }\n    const startAnimation = () => {\n        readyAnimation.cancel();\n        const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\n        /**\n         * Record the time of the first started animation. We call performance.now() once\n         * here and once in handoff to ensure we're getting\n         * close to a frame-locked time. This keeps all animations in sync.\n         */\n        if (startFrameTime === undefined) {\n            startFrameTime = performance.now();\n        }\n        appearAnimation.startTime = startFrameTime;\n        appearAnimationStore.set(storeId, {\n            animation: appearAnimation,\n            startTime: startFrameTime,\n        });\n        if (onReady)\n            onReady(appearAnimation);\n    };\n    appearComplete.set(id, false);\n    if (readyAnimation.ready) {\n        readyAnimation.ready.then(startAnimation).catch(noop);\n    }\n    else {\n        startAnimation();\n    }\n}\n\nexport { startOptimizedAppearAnimation };\n", "\"use client\";\nimport { useState, useLayoutEffect } from 'react';\nimport { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\nimport { createBox } from '../../projection/geometry/models.mjs';\nimport { VisualElement } from '../../render/VisualElement.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { animateVisualElement } from '../interfaces/visual-element.mjs';\n\nconst createObject = () => ({});\nclass StateVisualElement extends VisualElement {\n    constructor() {\n        super(...arguments);\n        this.measureInstanceViewportBox = createBox;\n    }\n    build() { }\n    resetTransform() { }\n    restoreTransform() { }\n    removeValueFromRenderState() { }\n    renderInstance() { }\n    scrapeMotionValuesFromProps() {\n        return createObject();\n    }\n    getBaseTargetFromProps() {\n        return undefined;\n    }\n    readValueFromInstance(_state, key, options) {\n        return options.initialState[key] || 0;\n    }\n    sortInstanceNodePosition() {\n        return 0;\n    }\n}\nconst useVisualState = makeUseVisualState({\n    scrapeMotionValuesFromProps: createObject,\n    createRenderState: createObject,\n});\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n */\nfunction useAnimatedState(initialState) {\n    const [animationState, setAnimationState] = useState(initialState);\n    const visualState = useVisualState({}, false);\n    const element = useConstant(() => {\n        return new StateVisualElement({\n            props: {\n                onUpdate: (v) => {\n                    setAnimationState({ ...v });\n                },\n            },\n            visualState,\n            presenceContext: null,\n        }, { initialState });\n    });\n    useLayoutEffect(() => {\n        element.mount({});\n        return () => element.unmount();\n    }, [element]);\n    const startAnimation = useConstant(() => (animationDefinition) => {\n        return animateVisualElement(element, animationDefinition);\n    });\n    return [animationState, startAnimation];\n}\n\nexport { useAnimatedState };\n", "\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { invariant } from 'motion-utils';\nimport * as React from 'react';\nimport { useConstant } from '../utils/use-constant.mjs';\nimport { LayoutGroup } from './LayoutGroup/index.mjs';\n\nlet id = 0;\nconst AnimateSharedLayout = ({ children }) => {\n    React.useEffect(() => {\n        invariant(false, \"AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations\");\n    }, []);\n    return (jsx(LayoutGroup, { id: useConstant(() => `asl-${id++}`), children: children }));\n};\n\nexport { AnimateSharedLayout };\n", "\"use client\";\nimport { invariant, warning } from 'motion-utils';\nimport { useContext } from 'react';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useMotionValue } from './use-motion-value.mjs';\nimport { useTransform } from './use-transform.mjs';\n\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\nconst maxScale = 100000;\nconst invertScale = (scale) => scale > 0.001 ? 1 / scale : maxScale;\nlet hasWarned = false;\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @deprecated\n */\nfunction useInvertedScale(scale) {\n    let parentScaleX = useMotionValue(1);\n    let parentScaleY = useMotionValue(1);\n    const { visualElement } = useContext(MotionContext);\n    invariant(!!(scale || visualElement), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\n    warning(hasWarned, \"useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.\");\n    hasWarned = true;\n    if (scale) {\n        parentScaleX = scale.scaleX || parentScaleX;\n        parentScaleY = scale.scaleY || parentScaleY;\n    }\n    else if (visualElement) {\n        parentScaleX = visualElement.getValue(\"scaleX\", 1);\n        parentScaleY = visualElement.getValue(\"scaleY\", 1);\n    }\n    const scaleX = useTransform(parentScaleX, invertScale);\n    const scaleY = useTransform(parentScaleY, invertScale);\n    return { scaleX, scaleY };\n}\n\nexport { invertScale, useInvertedScale };\n", "export { ReorderGroup as Group } from './Group.mjs';\nexport { ReorderItem as Item } from './Item.mjs';\n", "\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { invariant } from 'motion-utils';\nimport { forwardRef, useRef, useEffect } from 'react';\nimport { ReorderContext } from '../../context/ReorderContext.mjs';\nimport { motion } from '../../render/components/motion/proxy.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { checkReorder } from './utils/check-reorder.mjs';\n\nfunction ReorderGroupComponent({ children, as = \"ul\", axis = \"y\", onReorder, values, ...props }, externalRef) {\n    const Component = useConstant(() => motion[as]);\n    const order = [];\n    const isReordering = useRef(false);\n    invariant(Boolean(values), \"Reorder.Group must be provided a values prop\", \"reorder-values\");\n    const context = {\n        axis,\n        registerItem: (value, layout) => {\n            // If the entry was already added, update it rather than adding it again\n            const idx = order.findIndex((entry) => value === entry.value);\n            if (idx !== -1) {\n                order[idx].layout = layout[axis];\n            }\n            else {\n                order.push({ value: value, layout: layout[axis] });\n            }\n            order.sort(compareMin);\n        },\n        updateOrder: (item, offset, velocity) => {\n            if (isReordering.current)\n                return;\n            const newOrder = checkReorder(order, item, offset, velocity);\n            if (order !== newOrder) {\n                isReordering.current = true;\n                onReorder(newOrder\n                    .map(getValue)\n                    .filter((value) => values.indexOf(value) !== -1));\n            }\n        },\n    };\n    useEffect(() => {\n        isReordering.current = false;\n    });\n    return (jsx(Component, { ...props, ref: externalRef, ignoreStrict: true, children: jsx(ReorderContext.Provider, { value: context, children: children }) }));\n}\nconst ReorderGroup = /*@__PURE__*/ forwardRef(ReorderGroupComponent);\nfunction getValue(item) {\n    return item.value;\n}\nfunction compareMin(a, b) {\n    return a.layout.min - b.layout.min;\n}\n\nexport { ReorderGroup, ReorderGroupComponent };\n", "\"use client\";\nimport { createContext } from 'react';\n\nconst ReorderContext = createContext(null);\n\nexport { ReorderContext };\n", "import { mixNumber } from 'motion-dom';\nimport { moveItem } from 'motion-utils';\n\nfunction checkReorder(order, value, offset, velocity) {\n    if (!velocity)\n        return order;\n    const index = order.findIndex((item) => item.value === value);\n    if (index === -1)\n        return order;\n    const nextOffset = velocity > 0 ? 1 : -1;\n    const nextItem = order[index + nextOffset];\n    if (!nextItem)\n        return order;\n    const item = order[index];\n    const nextLayout = nextItem.layout;\n    const nextItemCenter = mixNumber(nextLayout.min, nextLayout.max, 0.5);\n    if ((nextOffset === 1 && item.layout.max + offset > nextItemCenter) ||\n        (nextOffset === -1 && item.layout.min + offset < nextItemCenter)) {\n        return moveItem(order, index, index + nextOffset);\n    }\n    return order;\n}\n\nexport { checkReorder };\n", "\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { isMotionValue } from 'motion-dom';\nimport { invariant } from 'motion-utils';\nimport { forwardRef, useContext } from 'react';\nimport { ReorderContext } from '../../context/ReorderContext.mjs';\nimport { motion } from '../../render/components/motion/proxy.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useMotionValue } from '../../value/use-motion-value.mjs';\nimport { useTransform } from '../../value/use-transform.mjs';\n\nfunction useDefaultMotionValue(value, defaultValue = 0) {\n    return isMotionValue(value) ? value : useMotionValue(defaultValue);\n}\nfunction ReorderItemComponent({ children, style = {}, value, as = \"li\", onDrag, layout = true, ...props }, externalRef) {\n    const Component = useConstant(() => motion[as]);\n    const context = useContext(ReorderContext);\n    const point = {\n        x: useDefaultMotionValue(style.x),\n        y: useDefaultMotionValue(style.y),\n    };\n    const zIndex = useTransform([point.x, point.y], ([latestX, latestY]) => latestX || latestY ? 1 : \"unset\");\n    invariant(Boolean(context), \"Reorder.Item must be a child of Reorder.Group\", \"reorder-item-child\");\n    const { axis, registerItem, updateOrder } = context;\n    return (jsx(Component, { drag: axis, ...props, dragSnapToOrigin: true, style: { ...style, x: point.x, y: point.y, zIndex }, layout: layout, onDrag: (event, gesturePoint) => {\n            const { velocity } = gesturePoint;\n            velocity[axis] &&\n                updateOrder(value, point[axis].get(), velocity[axis]);\n            onDrag && onDrag(event, gesturePoint);\n        }, onLayoutMeasure: (measured) => registerItem(value, measured), ref: externalRef, ignoreStrict: true, children: children }));\n}\nconst ReorderItem = /*@__PURE__*/ forwardRef(ReorderItemComponent);\n\nexport { ReorderItem, ReorderItemComponent };\n"],
  "mappings": "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",
  "names": ["import_jsx_runtime", "import_react", "import_jsx_runtime", "React", "import_react", "React", "id", "id", "import_react", "import_jsx_runtime", "import_react", "import_react", "import_react", "import_react", "id", "import_jsx_runtime", "import_react", "import_jsx_runtime", "import_react", "Component", "import_react", "import_react", "import_react", "time", "defaultOffset", "time", "listener", "progress", "import_react", "import_react", "import_react", "time", "import_react", "import_react", "animations", "keyframes", "keyframes", "keyframes", "keyframes", "delay", "getValueTransition", "keyframes", "animations", "animations", "keyframes", "animations", "animate", "keyframes", "getComputedStyle", "animations", "keyframes", "animate", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "frame", "keyframes", "id", "frame", "import_react", "import_jsx_runtime", "React", "import_react", "scale", "hasWarned", "import_jsx_runtime", "import_react", "import_react", "item", "Component", "layout", "import_jsx_runtime", "import_react", "layout", "Component", "point"]
}
